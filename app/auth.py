import functools
from flask import Blueprint, flash, g, redirect, render_template, request,session, url_for
from werkzeug.security import check_password_hash, generate_password_hash
from app.db import get_db
from flask_httpauth import HTTPBasicAuth, HTTPTokenAuth

from flask_oauth import OAuth
from flask_httpauth import HTTPBasicAuth
from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
import json

GOOGLE_CLIENT_ID = '911597646420-mt05m86o6knmunvn3pfmjc5n83c4qo9h.apps.googleusercontent.com'
GOOGLE_CLIENT_SECRET = '-WOQAJgcUV6ksGAc6VCp38qu'
REDIRECT_URI = '/gCallback'
oauth = OAuth()
#auth = HTTPBasicAuth()

google = oauth.remote_app('google',
                          base_url='https://www.google.com/accounts/',
                          authorize_url='https://accounts.google.com/o/oauth2/auth',
                          request_token_url=None,
                          request_token_params={'scope': 'https://www.googleapis.com/auth/userinfo.email',
                                                'response_type': 'code'},
                          access_token_url='https://accounts.google.com/o/oauth2/token',
                          access_token_method='POST',
                          access_token_params={'grant_type': 'authorization_code'},
                          consumer_key=GOOGLE_CLIENT_ID,
                          consumer_secret=GOOGLE_CLIENT_SECRET)

auth = HTTPBasicAuth()
#auth = HTTPTokenAuth(scheme = 'Token')

bp = Blueprint('auth', __name__, url_prefix='/auth')


@bp.route('/test')
def test():
    session['token'] = generate_token()
    return session['token']

def generate_token():
    s = Serializer('SECRET_KEY', expires_in = 6000)
    return s.dumps({'username':session['username']})

@bp.route('token')
@auth.login_required
def test_token():
    return "hello "

@auth.verify_password
def verify_password(username, password):
    s = Serializer('SECRET_KEY')
    try:
        data = s.loads(password)
    except:
        return False
    db = get_db()
    user = db.execute(
        'SELECT * FROM user WHERE username = ?', (username,)
    ).fetchone()
    if not user:
        return True
        #return False
    elif username != data['username']:
        return False
    else:
        #g.user = data['username']
        return True

@bp.route('/g')
def gindex():
    access_token = session.get('access_token')
    if access_token is None:
        return redirect('auth/gLogin')
 
    access_token = access_token[0]
    from urllib2 import Request, urlopen, URLError
 
    headers = {'Authorization': 'OAuth '+access_token}
    req = Request('https://www.googleapis.com/oauth2/v1/userinfo',
                  None, headers)
    try:
        res = urlopen(req)
    except URLError, e:
        if e.code == 401:
            # Unauthorized - bad token
            session.pop('access_token', None)
            return redirect(url_for('login'))
        return res.read()
    #me = google.get('userinfo')
    #return jsonify({"data": me.data})
    #return res.read()
    res_json = json.loads(res.read())
    #res_json['email']
    user = {'username':res_json['email']}
    g.user = user
    session['username'] = user['username']
    session['token'] = generate_token()

    return render_template('base.html')

@bp.route('/gLogin')
def glogin():
    callback=url_for('auth.authorized', _external=True)
    return google.authorize(callback=callback)

@bp.route(REDIRECT_URI)
@google.authorized_handler
def authorized(resp):
    access_token = resp['access_token']
    session['access_token'] = access_token, ''
    return redirect(url_for('auth.gindex'))


@google.tokengetter
def get_google_oauth_token():
    return session.get('google_token')

#@auth.verify_password
#def verify_password(username, password):
#    db = get_db()
#    user = db.execute(
#        'SELECT * FROM user WHERE username = ?', (username,)
#    ).fetchone()
#    error = None
#    if user is None:
#        error = 'Incorrect username.'
#    elif not check_password_hash(user['password'], password):
#        error = 'Incorrect password.'
#    return error is None

@bp.route('/register', methods=('GET', 'POST'))
def register():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        db = get_db()
        error = None

        if not username:
            error = 'Username is required.'
        elif not password:
            error = 'Password is required.'
        elif db.execute(
                'SELECT user_id FROM user WHERE username = ?', (username,)
        ).fetchone() is not None:
            error = 'User {} is already registered.'.format(username)

        if error is None:
            db.execute(
                'INSERT INTO user (username, password) VALUES (?, ?)',
                (username, generate_password_hash(password))
            )
            db.commit()
            return redirect(url_for('auth.login'))

        flash(error)

    return render_template('auth/register.html')

@bp.route('/login', methods=('GET', 'POST'))
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        db = get_db()
        error = None
        user = db.execute(
            'SELECT * FROM user WHERE username = ?', (username,)
        ).fetchone()

        if user is None:
            error = 'Incorrect username.'
        elif not check_password_hash(user['password'], password):
            error = 'Incorrect password.'

        if error is None:
            session.clear()
            session['user_id'] = user['user_id']
            session['username'] = user['username']
            #g.user = user['username']
            session['token'] = generate_token()
            return redirect(url_for('index'))
        flash(error)

    return render_template('auth/login.html')




@bp.before_app_request
def load_logged_in_user():
    user_id = session.get('user_id')

    if user_id is None:
        g.user = None
    else:
        g.user = get_db().execute(
            'SELECT * FROM user WHERE user_id = ?', (user_id,)
        ).fetchone()


@bp.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('index'))

def login_required(view):
    @functools.wraps(view)
    def wrapped_view(**kwargs):
        if g.user is None:
            return redirect(url_for('auth.login'))

        return view(**kwargs)

    return wrapped_view
